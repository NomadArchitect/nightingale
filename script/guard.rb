
require 'pathname'

def get_guard(content)
  content.each_line.take(5).each do |line|
    match = line.match /#ifndef (.*)/
    return match[1] if match
  end
  nil
end

class String
  def to_guard
    self.gsub("/", "_").upcase
  end
end

def strip_guard(f)
  new_content = []

  found_guard_ifndef = false
  found_guard_define = false
  line_number = 0
  f.each_line.each do |line|
    line_number += 1
    if line.match /pragma once/
      next
    end
    if !found_guard_ifndef and line_number < 5 and line.match /ifndef/
      found_guard_ifndef = true
      next
    end
    if found_guard_ifndef and !found_guard_define and line_number < 5 and line.match /define/
      found_guard_define = true
      next
    end

    new_content << line
  end

  if found_guard_ifndef
    new_content = new_content.reverse.drop_while{|l|l.match /^\s*$/}
    new_content.shift if new_content[0].match /endif/
    new_content = new_content.drop_while{|l|l.match /^\s*$/}
    new_content = new_content.reverse
  end

  new_content.drop_while{|l|l.match /^\s*$/}.join("")
end

def add_guard(content)
<<EOF
#pragma once

#{content}
EOF
  end

# TODO: option parsing
$options = {
  force: false
}

HEADER_DIRS = %w(fs include kernel libc linker modules sh user x86)
headers = HEADER_DIRS.map {
  |hd| Pathname.glob("#{hd}/**/*.h")
}.flatten
 .reject { |h| h.to_s.include? "autogenerated" }

headers.each do |header|
  filename = header.to_s
  if File.symlink?(filename)
    next
  end

  # f = File.open(filename)
  # now = get_guard(filename, f)
  # good = correct_guard(filename)

  # puts "#{filename}: #{now or "<>"} -> #{good}"
  # f.close

  f = File.open(filename)
  f.seek(0)

  stripped = strip_guard(f)
  fixed = add_guard(stripped)
  f.close

  f = File.open(filename, "w")
  f.puts(fixed)
  f.close
end

