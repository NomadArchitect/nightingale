
#include <basic.h>
#include <ng/panic.h>
#include <ng/string.h>
#include <ng/syscall.h>
#include <ng/syscalls.h> // syscall sys_* prototypes
#include <ng/thread.h>
#include <ng/vmm.h>
#include <ng/cpu.h>
#include <ng/fs.h>
#include <ng/syscall_consts.h>
#include <errno.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>

#include "autogenerated_syscalls.inc"

bool syscall_check_pointer(uintptr_t ptr) {
        uintptr_t resolved = vmm_resolve(ptr);
        if (resolved == ~0) {
                return false;
        }
        if (!(resolved & PAGE_USERMODE)) {
                return false;
        }
        return true;
}

void syscall_entry(interrupt_frame *r, int syscall) {
        if (running_thread->tracer) {
                trace_syscall_entry(running_thread, syscall);
        }
}

void syscall_exit(interrupt_frame *r, int syscall) {
        if (running_thread->tracer) {
                trace_syscall_exit(running_thread, syscall);
        }
}

#define check_ptr(enable, ptr) \
        if (enable && ptr != 0 && !syscall_check_pointer(ptr)) { \
                if (running_thread->flags & TF_SYSCALL_TRACE) \
                        printf(" -> <EFAULT>\n"); \
                return -EFAULT; \
        }

// Extra arguments are not passed or clobbered in registers, that is
// handled in arch/, anything unused is ignored here.
// arch/ code also handles the multiple return
sysret do_syscall_with_table(
        enum ng_syscall syscall_num,
        intptr_t arg1,
        intptr_t arg2,
        intptr_t arg3,
        intptr_t arg4,
        intptr_t arg5,
        intptr_t arg6,
        interrupt_frame *frame
) {

        if (syscall_num >= SYSCALL_MAX || syscall_num <= NG_INVALID) {
                panic("invalid syscall number: %i\n", syscall_num);
        }

        if (running_thread->flags & TF_SYSCALL_TRACE) {
                printf("[%i:%i] ", running_process->pid, running_thread->tid);
                printf(syscall_debuginfos[syscall_num],
                       arg1, arg2, arg3, arg4, arg5, arg6);
        }

        unsigned int mask = syscall_ptr_mask[syscall_num];
        check_ptr(mask & 0x01, arg1);
        check_ptr(mask & 0x02, arg2);
        check_ptr(mask & 0x04, arg3);
        check_ptr(mask & 0x08, arg4);
        check_ptr(mask & 0x10, arg5);
        check_ptr(mask & 0x20, arg6);

        sysret (*call)() = syscall_table[syscall_num];
        sysret ret = {0};

        if (call == 0) {
                ret = -EINVAL;
        } else {
                if (
                        syscall_num == NG_EXECVE ||
                        syscall_num == NG_FORK ||
                        syscall_num == NG_CLONE0
                ) {
                        ret = call(frame, arg1, arg2, arg3, arg4, arg5, arg6);
                } else {
                        ret = call(arg1, arg2, arg3, arg4, arg5, arg6);
                }
        }

        if (running_thread->flags & TF_SYSCALL_TRACE) {
                if (syscall_num == NG_STRACE) {
                        // This is just here to mark this as a strace return,
                        // since it can be confusing that " -> 0" appears
                        // after some other random syscall when the strace
                        // call returns.
                        printf("XX");
                }
                if (ret >= 0 && ret < 0x100000) {
                        printf(" -> %lu\n", ret);
                } else if (ret >= 0 || ret < -0x1000) {
                        printf(" -> %#lx\n", ret);
                } else {
                        printf(" -> <%s>\n", errno_names[-ret]);
                }
        }

        return ret;
}

