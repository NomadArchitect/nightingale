#include <basic.h>
#include <errno.h>
#include <ng/panic.h>
#include <ng/syscall.h>
#include <ng/syscall_consts.h>
#include <ng/syscalls.h> // syscall sys_* prototypes
#include <ng/thread.h>
#include <ng/vmm.h>
#include <stdint.h>
#include <stdio.h>

#include "autogenerated_syscalls.inc"

bool syscall_check_pointer(uintptr_t ptr) {
    uintptr_t *pte_ptr = vmm_pte_ptr(ptr);
    if (!pte_ptr) { return false; }
    if (!(*pte_ptr & PAGE_USERMODE)) { return false; }
    return true;
}

void syscall_entry(interrupt_frame *r, int syscall) {
    if (running_thread->tracer) {
        trace_syscall_entry(running_thread, syscall);
    }
}

void syscall_exit(interrupt_frame *r, int syscall) {
    if (running_thread->tracer) { trace_syscall_exit(running_thread, syscall); }
}

int syscall_register(int number, sysret (*fn)(), const char *debug,
                     unsigned ptr_mask) {
    if (number < 0 || number >= SYSCALL_TABLE_SIZE) { return -1; }
    if (syscall_table[number]) { return -1; }
    syscall_table[number] = fn;
    syscall_debuginfos[number] = debug;
    syscall_ptr_mask[number] = ptr_mask;
    return 0;
}

#define check_ptr(enable, ptr)                                                 \
    if (enable && ptr != 0 && !syscall_check_pointer(ptr)) {                   \
        if (running_thread->flags & TF_SYSCALL_TRACE)                          \
            printf(" -> <EFAULT>\n");                                          \
        return -EFAULT;                                                        \
    }

// Extra arguments are not passed or clobbered in registers, that is
// handled in arch/, anything unused is ignored here.
// arch/ code also handles the multiple return
sysret do_syscall(interrupt_frame *frame) {
    sysret ret;
    enum ng_syscall syscall_num = FRAME_SYSCALL(frame);
    syscall_entry(frame, syscall_num);

    uintptr_t arg1 = FRAME_ARG1(frame);
    uintptr_t arg2 = FRAME_ARG2(frame);
    uintptr_t arg3 = FRAME_ARG3(frame);
    uintptr_t arg4 = FRAME_ARG4(frame);
    uintptr_t arg5 = FRAME_ARG5(frame);
    uintptr_t arg6 = FRAME_ARG6(frame);

    if (syscall_num >= SYSCALL_TABLE_SIZE || syscall_num <= 0) {
        return -ENOSYS;
    }
    sysret (*syscall)() = syscall_table[syscall_num];
    if (!syscall) { return -ENOSYS; }

    if (running_thread->flags & TF_SYSCALL_TRACE) {
        printf("[%i:%i] ", running_process->pid, running_thread->tid);
        const char *info = syscall_debuginfos[syscall_num];
        printf(info, arg1, arg2, arg3, arg4, arg5, arg6);
    }

    unsigned int mask = syscall_ptr_mask[syscall_num];
    check_ptr(mask & 0x01, arg1);
    check_ptr(mask & 0x02, arg2);
    check_ptr(mask & 0x04, arg3);
    check_ptr(mask & 0x08, arg4);
    check_ptr(mask & 0x10, arg5);
    check_ptr(mask & 0x20, arg6);

    if (syscall_num == NG_EXECVE || syscall_num == NG_FORK ||
        syscall_num == NG_CLONE0) {
        ret = syscall(frame, arg1, arg2, arg3, arg4, arg5, arg6);
    } else {
        ret = syscall(arg1, arg2, arg3, arg4, arg5, arg6);
    }

    if (running_thread->flags & TF_SYSCALL_TRACE) {
        if (syscall_num == NG_STRACE) {
            // This is just here to mark this as a strace return,
            // since it can be confusing that " -> 0" appears
            // after some other random syscall when the strace
            // call returns.
            printf("XX");
        }
        if (ret >= 0 && ret < 0x100000) {
            printf(" -> %lu\n", ret);
        } else if (ret >= 0 || ret < -0x1000) {
            printf(" -> %#lx\n", ret);
        } else {
            printf(" -> <%s>\n", errno_names[-ret]);
        }
    }

    FRAME_RETURN(frame) = ret;
    syscall_exit(frame, syscall_num);
    handle_pending_signals();

    return ret;
}
